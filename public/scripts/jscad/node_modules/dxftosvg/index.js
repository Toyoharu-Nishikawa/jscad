
"use strict";

import interpolate from '../b-spline/index.js'
import format from '../positional-format/index.js'

String.prototype.format = format

const groupCodes = new Map([
  [0,  'entityType'],
  [2,  'blockName'],
  [10, 'x'],
  [11, 'x1'],
  [20, 'y'],
  [21, 'y1'],
  [40, 'r'],
  [50, 'a0'],
  [51, 'a1'],
  [71, 'degree'],
  [72, 'numOfKnots'],
  [73, 'numOfControlPoints'],
  [74, 'numOfFitPoints'],
])

const supportedEntities = new Set([
  'LINE',
  'CIRCLE',
  'ARC',
  'LWPOLYLINE',
  'SPLINE'
])

const getLineSvg = (x1, y1, x2, y2) => {
  return '<path d="M{0},{1} {2},{3}"/>\n'.format(x1, y1, x2, y2)
}

const deg2rad = deg => {
  return deg * (Math.PI/180);
}


const getSvgSnippet = (type, param) => {

  switch (type) {
    case 'line': {
      const points = param.points
      return getLineSvg(points[0][0], points[0][1], points[1][0], points[1][1])
    }
    case 'circle': {
      return '<circle cx="{0}" cy="{1}" r="{2}"/>\n'.format(param.center[0], param.center[1], param.radius)
    }
    case 'arc': {
      const center = param.center
      const radius = param.radius
      const start = param.start
      const end = param.end
      const x1 = center[0] + radius * Math.cos(deg2rad(start))
      const y1 = center[1] + radius * Math.sin(deg2rad(start))
      const x2 = center[0] + radius * Math.cos(deg2rad(end))
      const y2 = center[1] + radius * Math.sin(deg2rad(end))


      const correctedEnd = end < start ? end + 360 : end
      const largeArcFlag = correctedEnd - start > 180 ? 1 : 0

      return '<path d="M{0},{1} A{2},{3} 0 {4},1 {5},{6}"/>\n'.
                      format(x1, y1, radius, radius, largeArcFlag, x2, y2)
    }
    case 'polyline': {
      let svgSnippet = '';
      const vertices = param.points
      for (let i=0; i<vertices.length-1; i++) {
        const vertice1 = vertices[i]
        const vertice2 = vertices[i+1]
        svgSnippet += getLineSvg(vertice1.x, vertice1.y, vertice2.x, vertice2.y)
      }
      return svgSnippet
    }
    case 'bspline': {
      let svgSnippet = '';
      const controlPoints = param.points
      const numOfKnots = param.numOfKnots
      const knots = param.knots
      const degree = param.degree
      const vertices = []
      for(let t=0;t<=100;t++){
        vertices.push(interpolate(t/100, degree, controlPoints, knots))
      }
      for (let i=0; i<vertices.length-1; i++) {
        const vertice1 = vertices[i]
        const vertice2 = vertices[i+1]
        svgSnippet += getLineSvg(vertice1[0], vertice1[1], vertice2[0], vertice2[1])
      }
      return svgSnippet
    }
  }
}

const dxfToObj = dxfObject => {

  switch (dxfObject.type) {
    case 'LINE': {
      const param = {type: "line", points: [ [dxfObject.x, dxfObject.y], [dxfObject.x1, dxfObject.y1] ] }
      return param 
    }
    case 'CIRCLE': {
      const param = {type: "circle", center: [dxfObject.x, dxfObject.y], radius: dxfObject.r }
      return param 
    }
    case 'ARC': {
      const param = {type: "arc", center: [dxfObject.x, dxfObject.y], radius: dxfObject.r, start:dxfObject.a0, end: dxfObject.a1  }
      return param 
    }
    case 'LWPOLYLINE': {
      const vertices = dxfObject.vertices;
      const points = []
      const N = vertices.length
      for (let i=0; i<N; i++) {
        const x = vertices[i].x
        const y = vertices[i].y
        const point = [x, y]
        points.push(point)
      }
      const param = {type: "polyline", points: points}
      return param 
    }
    case 'SPLINE': {
      const vertices = dxfObject.vertices;
      const points = []
      const N = vertices.length
      for (let i=0; i<N; i++) {
        const x = vertices[i].x
        const y = vertices[i].y
        const point = [x, y]
        points.push(point)
      }

      const knots = dxfObject.knots;
      const degree = dxfObject.degree;
      const param = {type: "bspline", points: points, knots: knots, degree: degree}

      return param 
    }
  }
}

export const parseDxf = dxfString => {

  let code = null
  let isEntitiesSectionActive = false
  let object = {}
  const objList = []
  //let svg = ''

  // Normalize platform-specific newlines.

  const lines = dxfString.split(/\r?\n/)
  const N = lines.length

  
  for(let i=0; i<N; i++){
    const value = lines[i].trim()
    if(i%2===0){
      code = parseInt(value)
      continue
    }
    const groupCode = groupCodes.get(code)

    if(groupCode === 'blockName' && value === 'ENTITIES') {
      isEntitiesSectionActive = true
      continue
    }

    if(isEntitiesSectionActive) {
      if(groupCode === 'entityType') {  // New entity starts or ends. code = 0
        if (object.type) {
          objList.push(object)
        }
        object = supportedEntities.has(value) ? {type: value} : {}
        if (value === 'ENDSEC') {
          isEntitiesSectionActive = false
        }
      }
      else if (object.type && typeof groupCode !== 'undefined') {  // Known entity property recognized.
        object[groupCode] = parseFloat(value)
        if ( object.type == 'SPLINE'  && groupCode === 'r') {
          if(!object.knots){
            object.knots =[]
          }
          object.knots.push(object.r)
        }
        if ( (object.type == 'LWPOLYLINE' || object.type == 'SPLINE')  && groupCode === 'y') {
          if (!object.vertices) {
            object.vertices = []
          }
          object.vertices.push({x:object.x, y:object.y})
        }
      }
    }
  } 

  return objList 
}



export const getParamFromDxf = dxfString => {
  const objList = parseDxf(dxfString )
  const N = objList.length
  const objects = []
  for(let i=0; i<N; i++){
    const obj = dxfToObj(objList[i])
    objects.push(obj) 
  }
  return objects 
}

export const getSvgFromParam = objList => {
  let svg = ""
  const N = objList.length
  for(let i=0; i<N;i++){
    svg += getSvgSnippet(objList[i].type, objList[i])
  }
  return svg
}

export const dxftosvg = dxfString => {
  const objList = getParamFromDxf(dxfString )
  const svg = getSvgFromParam(objList)
  return svg 
}

