"use strict"
import {tool} from "./tool.js"

export const  ApplicationMessage = class{
  constructor(e, connection, post){
    this.port= null 
    this.methodMap = new Map() 
    this.initialize(e, connection, post)
  }
  initialize(e, connection, post){
    this.port = e.ports[0]
    this.messageListen(post)

    this.port.onmessage = this.handleMessage.bind(this)
    this.port.start()
    this.fetch("/INITIAL_CONNECTION", connection)
  }
  handleMessage(e){
    const data = e.data
    const port = e.target     
    const method = data.method
    const func = this.methodMap.get(method) 
    func(data, port)
  }
  app(text, func){
    this.methodMap.set(text, func)
  }
  messageListen(post) {
    const eventName = ".FETCH_RESPONSE"
    this.app("FETCH_RESPONSE", (req, res)=>{
      const ev = new CustomEvent(eventName, {detail: req})
      document.dispatchEvent(ev)
    })
    this.app("FETCH_REQUEST", async (req, res)=>{
      const url = req.url
      const reqData = req.data
      const postData = await post(url, reqData) 
      const data = {
        method: "FETCH_RESPONSE",
        url: null,
        data: postData,
      }
      res.postMessage(data)
    })
  }
  fetch(url, data, callback){
    const self = this
    const eventName = ".FETCH_RESPONSE"
    const postData = {
      method: "FETCH_REQUEST",
      url : url,
      data: data
    }
    return new Promise((resolve, reject)=>{
      const deal = (e)=>{
        resolve(e.detail.data)
        if(callback){
          callback(e.detail.data)
        }
      }
      document.addEventListener(eventName, deal, {once:true});
      self.port.postMessage(postData)
    })
  }
}

export const Workbench = class{
  constructor(connection, post){
    this.message = null
    this.connection = connection
    this.initialize(connection, post)
  }
  initialize(connection, post){
    const self = this
    const f = (e)=>{
      const message = new  ApplicationMessage(e, connection, post)
      this.message = message
      this.connection = connection 
      document.addEventListener("Workbench.update.fire", self.update.bind(self))
      tool.setWorkbenchButton.execute()
    }
    window.onmessage = f 
  }
  async update(){
    const data =  {
      connection:this.connection 
    }
    const startEvent = "Workbench.update.start"
    const evs = new CustomEvent(startEvent)
    document.dispatchEvent(evs)
 
    const result = await this.message.fetch("/update", data)  

    const endEvent = "Workbench.update.end"
    const eve = new CustomEvent(endEvent, {detail: result})
    document.dispatchEvent(eve)

    return new Promise((resolve, reject)=>{
      resolve(result)
    })
  }
}

